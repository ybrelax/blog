---
category: 前端
tags:
  - webpack
date: 2020-03-23
title: webpack基础讲解
---

webpack 是一个应用程序的打包工具，通过 webpck 可以加载各种依赖。

总之你掌握了 webpack 你就掌握了你项目的最佳配置方案。 come On 学起来，用起来

<!--more-->

## webpack 核心

- entry: 入口
- output: 出口
- loader: 模块转换器
- plugins: 你所需要的加载器

## 初始化项目

1.  创建项目名 first-test, 然后初始化 npm init

2.  安装 webpack

```js
npm install webpack webpack-cli -D
```

3.  建立象应的文件

```js
// src/index.js
const initWebpack = () => {
  console.log("hello webpack");
};
initWebpack();
```

使用 **npmx webpack --mode=development** 进行直接构建，这种构建方式是开发模式，方便看到源码

webpack 是有默认配置项目，如默认的入口文件时./src, 默认的打包到 dist/main.js.更多的默认配置可以查看**node_modules/webpack/lib/WebpackOptionsDefaulter.js**

得到如下结果

```js
eval(
  "const initWebpack = () => {\r\n    console.log('hello webpack')\r\n}\r\n\r\nclass Teacher {\r\n    constructor(name) {\r\n        this.name = name;\r\n    }\r\n    getName() {\r\n        return this.name\r\n    }\r\n}\r\ninitWebpack()\n\n//# sourceURL=webpack:///./src/index.js?"
);
```

可以看到 class 并没有转化为兼容函数，这样就容易导致兼容问题。

## 转化 JS 为低版本

怎么才能保证浏览器的兼容性，以及怎么用最新的语法。这就用到了 webpack 的核心 loader, loader 就是对源码进行转化。

这里我们需要用到 babel-loader

```js
npm install babel-loader -D
```

除此之外，还需要配置 babel

```js
npm install @babel/core @babel/preset-env @babel/plugin-transform-runtime -D

npm install @babel/runtime @babel/runtime-corejs3
```

新建**webpack.config.js**,如下

```js
module.exports = {
  module: {
    rules: [
      {
        test: /\.jsx?$/, // 正则判断文件后缀名
        use: ["babel-loader"], //使用什么loader
        exclude: /node_modules/ //排除 node_modules 目录
      }
    ]
  }
};
```

对于 babel 的配置，我们可以在.babelrc 中配置，也可以在 weabpack.config.js 中配置

### 创建一个.babelrc 文件

```js
{
    "presets": ["@babel/preset-env"],
    "plugins": [
        [
            "@babel/plugin-transform-runtime",
            {
                "corejs": 3
            }
        ]
    ]
}
```

### 在 webpack 中的配置

```js
module.exports = {
  // mode: 'development',
  module: {
    rules: [
      {
        test: /\.jsx?$/,
        use: {
          loader: "babel-loader",
          options: {
            presets: ["@babel/preset-env"],
            plugins: [
              [
                "@babel/plugin-transform-runtime",
                {
                  corejs: 3
                }
              ]
            ]
          }
        },
        exclude: /node_modules/
      }
    ]
  }
};
```

这样再次进行打包，就可以看到能兼容的版本，而不是 class

有几点要进行说明

- loader 需要配置在 module.rules 中，rules 是一个数组
- loader 格式为

```js
{
    test: /\.jsx?$/,//匹配规则
    use: 'babel-loader'
}
```

或者

```js
{
    test: /\.jsx?$/,
    loader: 'babel-loader',
    options: {
        //...
    }
}
```

**test** 文件匹配规则

**use** 使用的 loader，它有集中写法

1.  它可以是数组，如这样 use: ['style-loader', 'css-loader']
2.  它的每一项可以是字符也可以是对象，当我们需要对 loader 进行配置的时候，可以写成一个对象，并将此对象的 options 进行配置，如：

```js
rules: [
  {
    test: /\.jsx?$/,
    use: {
      loader: "babel-loader",
      options: {
        presets: ["@babel/preset-env"]
      }
    },
    exclude: /node_modules/
  }
];
```

## mode

将 mode 增加到 webpack.config.js 中

```js
module.exports = {
  //....
  mode: "development",
  module: {
    //...
  }
};
```

mode 配置项，告知 webpack 使用相应的模式进行优化。

- development: 将 process.env.NODE_ENV 的值设置为**developent**, 启用 _NamedChunksPlugin_ 和 _NamedModulesPlugin_

- production: 将 process.env.NODE*ENV 的值设置为**production**,启用 \_FlagDependencyUsagePlugin*, _FlagIncludedChunksPlugin_, _ModuleConcatenationPlugin_, _NoEmitOnErrorsPlugin_, _OccurrenceOrderPlugin_, _SideEffectsFlagPlugin_ 和 _UglifyJsPlugin_

## 在浏览器中查看页面

 当我们用脚手架编译项目的时候，js的名字会带上hash值，让我们页面能够及时更新，而不用加载到缓存。那怎么让html每次都能访问正确的js呢？

 这里我们可以用到**html-webpack-plugin**插件
 
 ```js
 npm install html-webpack-plugin -D 
 ```
 然我们在public上建立一个**index.html**文件

 这里介绍一下该插件**config**的妙用
  
  如果想每次打包都引用不同的工共资源，该如何处理呢

首先配置工共管理文件
```js
 module.exports = {
    dev: {
        template: {
            title: '你好',
            header: false,
            footer: false
        }
    },
    build: {
        template: {
            title: '你好才怪',
            header: true,
            footer: false
        }
    }
}
```
然后我们对webpack.config.js进行配置
```js
//webpack.config.js
const HtmlWebpackPlugin = require('html-webpack-plugin');
const isDev = process.env.NODE_ENV === 'development';
const config = require('./public/config')[isDev ? 'dev' : 'build'];

modue.exports = {
    //...
    mode: isDev ? 'development' : 'production'
    plugins: [
        new HtmlWebpackPlugin({
            template: './public/index.html',
            filename: 'index.html', //打包后的文件名
            config: config.template
        })
    ]

```
然后我们在对index.html文件进行修改
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <% if(htmlWebpackPlugin.options.config.header) { %>
    <link rel="stylesheet" type="text/css" href="//common/css/header.css">
    <% } %>
    <title><%= (htmlWebpackPlugin.options.config.title) %></title>
</head>

<body>
</body> 
<!--公共资源-->
<% if(htmlWebpackPlugin.options.config.header) { %>
<script src="//common/header.min.js" type="text/javascript"></script> 
<% } %>
</html>
```
上面有一块配置比较奇怪，就是我们并没有 **NODE_ENV**这个变量，同时为了兼容处理可以安装
```js
npm install cross-env -D
```
* 启动项
```js
{
    "scripts": {
        "dev": "cross-env NODE_ENV=development webpack",
        "build": "cross-env NODE_ENV=production webpack"
    }
}

```

### 安装服务

如何以服务的形式去启动这个项目，这时候我们可能就需要使用这个依赖了
```js
npm install webpack-dev-server -D
```
```js
"dev": "cross-env NODE_ENV=development webpack-dev-server",
```