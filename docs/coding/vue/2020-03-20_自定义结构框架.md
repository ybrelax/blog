---
category: 编程
tags:
  - vue
date: 2020-03-30
title: 自定义vue + ts后台架构
---

虽然官方给了我们脚手架，提供了相应的配置，但是自己配置可能才是最适合自己的，所以让我们走起。

<!--more-->

> 鉴于之前有介绍 react 篇章，所以这篇主要集中在配置上的一些问题和优化

## 错误提示

### decorators-legacy

```js
support for the experimental syntax 'decorators-legacy' isn't currrently enabled
```

结合错误提示，参考[官方连接](https://babeljs.io/docs/en/babel-plugin-proposal-decorators) , 得到如下配置:

```js
{
    test: /\.tsx?$/,
    exclude: /node_modules/,
    use: {
        loader: 'babel-loader',
        options: {
        presets: [
            '@babel/preset-env',
            '@babel/preset-typescript',
        ],
        plugins: [
            ["@babel/plugin-proposal-decorators", { "legacy": true }],
            ["@babel/plugin-proposal-class-properties", { "loose": false }]
        ]
        }
    }
}
```

### 识别不了 :xxx private 这些语法

之前看了一遍[文章](https://www.bbsmax.com/A/l1dyZbrGze/), 用@babel/preset-typescript 取代 awesome-typescript-loader 和 ts-loader,导致 vue 识别语法有问题
，可能目前语法支持还不是很好

before:

```js
 {
    test: /\.tsx?$/,
    exclude: /node_modules/,
    use: {
        loader: 'babel-loader',
        options: {
        presets: [
            '@babel/preset-env',
            '@babel/preset-typescript',
        ],
        plugins: [
            ["@babel/plugin-proposal-decorators", { "legacy": true }],
            ["@babel/plugin-proposal-class-properties", { "loose": false }]
        ]
        }
    }
}
```

改为：

```js
{
    test: /\.tsx?$/,
    exclude: /node_modules/,
    use: [{
        loader: 'babel-loader'
    }
    ,{
        loader: 'ts-loader',
        options: {
        transpileOnly: true,
        appendTsSuffixTo: ['\\.vue$'],
        happyPackMode: true
        }
    }
    ]
}
```

## 状态管理Vuex

在ts中进行状态管常用的一个组件为**vue-class-component**, 它是基于**vuex-module-decorators**进行拓展的。

可以看下我目前的一个状态管理结构
```js
|-- index.ts
|-- modules
        |-- permission.ts
        |-- user.ts
```
熟悉下之前的vuex
```js
export default new Vuex.Store({
    state: {
    },
    mutations: {
    },
    actions: {
    },
    modules: {
    }
});
```

然后可以看下我们ts的结构
```js
import {
  Module,
  Mutation,
  VuexModule,
  Action,
  getModule
} from "vuex-module-decorators";
import { login } from "@/apis/users";
import store from "@/store";

export interface IUserState {
  token: string;
  name: string;
  roles: string[];
}

@Module({ dynamic: true, store, name: "user" })
class User extends VuexModule implements IUserState {
  public token = "";
  public name = "";
  public roles: string[] = [];

  @Mutation
  private SET_TOKEN(token: string) {
    this.token = token;
  }

  @Mutation
  private SET_NAME(name: string) {
    this.name = name;
  }

  @Mutation
  private SET_ROLES(roles: string[]) {
    this.roles = roles;
  }

  @Action
  public async Login(userInfo: { username: string; password: string }) {
    let { username, password } = userInfo;
    username = username.trim();
    const {data} = await login({ username, password });
    if (!data) {
      return false;
    } else {
      return true;
    }
  }
}

export const UserModule = getModule(User);
```
1. 定义Module

 @Module 等同于之前的modules, 用于定义一个modules

> @Module({ dynamic: true, store, name: 'user' })
* dynamic 当store构建的时候，动态的注入到store
* name 指定 module的名字
* store 注入到哪个store

2. state
实现了类型接口，定义的时候要设置为public

3. Getter

实现方式稍有不同
```ts
@Module
export default class UserModule extends VuexModule {
  name = 'ybrelax'
  
  get getName() {
    return name
  }
}
```
4. Mutation / Action

@Mutation @Action 采用注解的方式注入，记得区别
* Mutation 用于处理同步逻辑
* Action 用于处于异步逻辑

